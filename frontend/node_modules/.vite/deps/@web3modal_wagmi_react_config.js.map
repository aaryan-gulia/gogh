{
  "version": 3,
  "sources": ["../../@web3modal/polyfills/index.ts", "../../@wagmi/connectors/src/coinbaseWallet.ts", "../../@wagmi/connectors/src/metaMask.ts", "../../@wagmi/connectors/src/safe.ts", "../../@wagmi/connectors/src/walletConnect.ts", "../../@web3modal/wagmi/src/connectors/EmailConnector.ts", "../../@web3modal/wagmi/src/utils/defaultWagmiReactConfig.ts"],
  "sourcesContent": [null, "import {\n  type CoinbaseWalletProvider,\n  type CoinbaseWalletSDK,\n} from '@coinbase/wallet-sdk'\nimport {\n  ChainNotConfiguredError,\n  createConnector,\n  normalizeChainId,\n} from '@wagmi/core'\nimport type { Evaluate, Mutable, Omit } from '@wagmi/core/internal'\nimport {\n  type ProviderRpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getAddress,\n  numberToHex,\n} from 'viem'\n\n// TODO(@3): Set `enableMobileWalletLink` to `true`\nexport type CoinbaseWalletParameters = Evaluate<\n  Mutable<\n    Omit<\n      ConstructorParameters<typeof CoinbaseWalletSDK>[0],\n      'reloadOnDisconnect' // remove property since TSDoc says default is `true`\n    >\n  > & {\n    /**\n     * Fallback Ethereum JSON RPC URL\n     * @default \"\"\n     */\n    jsonRpcUrl?: string | undefined\n    /**\n     * Fallback Ethereum Chain ID\n     * @default 1\n     */\n    chainId?: number | undefined\n    /**\n     * Whether or not to reload dapp automatically after disconnect.\n     * @default false\n     */\n    reloadOnDisconnect?: boolean | undefined\n  }\n>\n\ncoinbaseWallet.type = 'coinbaseWallet' as const\nexport function coinbaseWallet(parameters: CoinbaseWalletParameters) {\n  const reloadOnDisconnect = false\n\n  type Provider = CoinbaseWalletProvider\n  type Properties = {}\n\n  let sdk: CoinbaseWalletSDK | undefined\n  let walletProvider: Provider | undefined\n\n  return createConnector<Provider, Properties>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        provider.on('accountsChanged', this.onAccountsChanged)\n        provider.on('chainChanged', this.onChainChanged)\n        provider.on('disconnect', this.onDisconnect.bind(this))\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return { accounts, chainId: currentChainId }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      provider.removeListener('accountsChanged', this.onAccountsChanged)\n      provider.removeListener('chainChanged', this.onChainChanged)\n      provider.removeListener('disconnect', this.onDisconnect.bind(this))\n\n      provider.disconnect()\n      provider.close()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        await provider.request<string[]>({\n          method: 'eth_accounts',\n        })\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = await provider.request<number>({ method: 'eth_chainId' })\n      return normalizeChainId(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        const { default: CoinbaseWalletSDK } = await import(\n          '@coinbase/wallet-sdk'\n        )\n        let SDK: typeof CoinbaseWalletSDK.default\n        if (\n          typeof CoinbaseWalletSDK !== 'function' &&\n          typeof CoinbaseWalletSDK.default === 'function'\n        )\n          SDK = CoinbaseWalletSDK.default\n        else\n          SDK = CoinbaseWalletSDK as unknown as typeof CoinbaseWalletSDK.default\n        sdk = new SDK({ reloadOnDisconnect, ...parameters })\n\n        // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.\n        const walletExtensionChainId = (\n          sdk as unknown as {\n            get walletExtension(): { getChainId(): number } | undefined\n          }\n        ).walletExtension?.getChainId()\n\n        const chain =\n          config.chains.find((chain) =>\n            parameters.chainId\n              ? chain.id === parameters.chainId\n              : chain.id === walletExtensionChainId,\n          ) || config.chains[0]\n        const chainId = parameters.chainId || chain?.id\n        const jsonRpcUrl =\n          parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0]\n\n        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId)\n      }\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n      const chainId_ = numberToHex(chain.id)\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: chainId_ }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [\n                {\n                  chainId: chainId_,\n                  chainName: chain.name,\n                  nativeCurrency: chain.nativeCurrency,\n                  rpcUrls: [chain.rpcUrls.default?.http[0] ?? ''],\n                  blockExplorerUrls: [chain.blockExplorers?.default.url],\n                },\n              ],\n            })\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) config.emitter.emit('disconnect')\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = normalizeChainId(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      provider.removeListener('accountsChanged', this.onAccountsChanged)\n      provider.removeListener('chainChanged', this.onChainChanged)\n      provider.removeListener('disconnect', this.onDisconnect.bind(this))\n    },\n  }))\n}\n", "import {\n  EventType,\n  type MetaMaskSDK,\n  type MetaMaskSDKOptions,\n  type SDKProvider,\n} from '@metamask/sdk'\nimport {\n  ChainNotConfiguredError,\n  createConnector,\n  normalizeChainId,\n} from '@wagmi/core'\nimport type { Evaluate, ExactPartial, Omit } from '@wagmi/core/internal'\nimport {\n  type Address,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  ResourceUnavailableRpcError,\n  RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  type WalletPermission,\n  getAddress,\n  numberToHex,\n} from 'viem'\n\nexport type MetaMaskParameters = Evaluate<\n  ExactPartial<\n    Omit<\n      MetaMaskSDKOptions,\n      | 'checkInstallationImmediately'\n      | 'checkInstallationOnAllCalls'\n      | 'defaultReadOnlyChainId'\n      | 'readonlyRPCMap'\n    >\n  >\n>\n\nmetaMask.type = 'metaMask' as const\n/**\n * @deprecated\n *\n * __Warning__ This connector has a large file size due to the underlying `@metamask/sdk`. For mobile\n * support, it is recommended to use {@link walletConnect}. For desktop support, you should rely on Multi Injected\n * Provider Discovery (EIP-6963) via the Wagmi {@link Config}.\n */\nexport function metaMask(parameters: MetaMaskParameters = {}) {\n  type Provider = SDKProvider\n  type Properties = {\n    onConnect(connectInfo: ProviderConnectInfo): void\n  }\n  type StorageItem = { 'metaMaskSDK.disconnected': true }\n  type Listener = Parameters<Provider['on']>[1]\n\n  let sdk: MetaMaskSDK\n  let walletProvider: Provider | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'metaMaskSDK',\n    name: 'MetaMask',\n    type: metaMask.type,\n    async setup() {\n      const provider = await this.getProvider()\n      if (provider)\n        provider.on('connect', this.onConnect.bind(this) as Listener)\n    },\n    async connect({ chainId, isReconnecting } = {}) {\n      const provider = await this.getProvider()\n\n      let accounts: readonly Address[] | null = null\n      if (!isReconnecting) {\n        accounts = await this.getAccounts().catch(() => null)\n        const isAuthorized = !!accounts?.length\n        if (isAuthorized)\n          // Attempt to show another prompt for selecting account if already connected\n          try {\n            const permissions = (await provider.request({\n              method: 'wallet_requestPermissions',\n              params: [{ eth_accounts: {} }],\n            })) as WalletPermission[]\n            accounts = (permissions[0]?.caveats?.[0]?.value as string[])?.map(\n              (x) => getAddress(x),\n            )\n          } catch (err) {\n            const error = err as RpcError\n            // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n            // Only bubble up error if user rejects request\n            if (error.code === UserRejectedRequestError.code)\n              throw new UserRejectedRequestError(error)\n            // Or prompt is already open\n            if (error.code === ResourceUnavailableRpcError.code) throw error\n          }\n      }\n\n      try {\n        if (!accounts?.length) {\n          const requestedAccounts = (await sdk.connect()) as string[]\n          accounts = requestedAccounts.map((x) => getAddress(x))\n        }\n\n        provider.removeListener(\n          'connect',\n          this.onConnect.bind(this) as Listener,\n        )\n        provider.on(\n          'accountsChanged',\n          this.onAccountsChanged.bind(this) as Listener,\n        )\n        provider.on('chainChanged', this.onChainChanged as Listener)\n        provider.on('disconnect', this.onDisconnect.bind(this) as Listener)\n\n        // Backward compatibility with older wallet (<7.3) version that return accounts before authorization\n        if (!sdk.isExtensionActive() && !sdk._getConnection()?.isAuthorized()) {\n          function waitForAuthorized() {\n            return new Promise((resolve) => {\n              const connection = sdk._getConnection()\n              const connector = connection?.getConnector()\n              connector?.once(EventType.AUTHORIZED, () => resolve(true))\n            })\n          }\n          await waitForAuthorized()\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        await config.storage?.removeItem('metaMaskSDK.disconnected')\n\n        return { accounts, chainId: currentChainId }\n      } catch (err) {\n        const error = err as RpcError\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        if (error.code === ResourceUnavailableRpcError.code)\n          throw new ResourceUnavailableRpcError(error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      provider.removeListener(\n        'accountsChanged',\n        this.onAccountsChanged.bind(this),\n      )\n      provider.removeListener('chainChanged', this.onChainChanged)\n      provider.removeListener('disconnect', this.onDisconnect.bind(this))\n      provider.on('connect', this.onConnect.bind(this) as Listener)\n\n      sdk.terminate()\n\n      // Add shim signalling connector is disconnected\n      await config.storage?.setItem('metaMaskSDK.disconnected', true)\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[]\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId =\n        provider.chainId ?? (await provider?.request({ method: 'eth_chainId' }))\n      return normalizeChainId(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        if (!sdk || !sdk?.isInitialized()) {\n          const { MetaMaskSDK } = await import('@metamask/sdk')\n          sdk = new MetaMaskSDK({\n            dappMetadata: { name: 'wagmi' },\n            enableAnalytics: false,\n            extensionOnly: true,\n            modals: {\n              // Disable by default since it pops up when mobile tries to reconnect\n              otp() {\n                const noop = () => {}\n                return { mount: noop, unmount: noop }\n              },\n            },\n            useDeeplink: true,\n            _source: 'wagmi',\n            ...parameters,\n            checkInstallationImmediately: false,\n            checkInstallationOnAllCalls: false,\n          })\n          await sdk.init()\n        }\n        try {\n          walletProvider = sdk.getProvider()\n        } catch (error) {\n          // TODO: SDK sometimes throws errors when MM extension or mobile provider is not detected (don't throw for those errors)\n          const regex = /^SDK state invalid -- undefined( mobile)? provider$/\n          if (!regex.test((error as Error).message)) throw error\n        }\n      }\n      return walletProvider!\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          // If shim exists in storage, connector is disconnected\n          await config.storage?.getItem('metaMaskSDK.disconnected')\n        if (isDisconnected) return false\n\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ chainId }) {\n      const provider = await this.getProvider()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      try {\n        await Promise.all([\n          provider.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{ chainId: numberToHex(chainId) }],\n          }),\n          new Promise<void>((resolve) =>\n            config.emitter.once('change', ({ chainId: currentChainId }) => {\n              if (currentChainId === chainId) resolve()\n            }),\n          ),\n        ])\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        // Indicates chain is not added to provider\n        if (\n          error.code === 4902 ||\n          // Unwrapping for MetaMask Mobile\n          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n          (error as ProviderRpcError<{ originalError?: { code: number } }>)\n            ?.data?.originalError?.code === 4902\n        ) {\n          try {\n            const { default: blockExplorer, ...blockExplorers } =\n              chain.blockExplorers ?? {}\n            let blockExplorerUrls: string[] = []\n            if (blockExplorer)\n              blockExplorerUrls = [\n                blockExplorer.url,\n                ...Object.values(blockExplorers).map((x) => x.url),\n              ]\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [\n                {\n                  chainId: numberToHex(chainId),\n                  chainName: chain.name,\n                  nativeCurrency: chain.nativeCurrency,\n                  rpcUrls: [chain.rpcUrls.default?.http[0] ?? ''],\n                  blockExplorerUrls,\n                },\n              ],\n            })\n\n            const currentChainId = await this.getChainId()\n            if (currentChainId !== chainId)\n              throw new UserRejectedRequestError(\n                new Error('User rejected switch after adding network.'),\n              )\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        throw new SwitchChainError(error)\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect()\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString()\n        this.onConnect({ chainId })\n        await config.storage?.removeItem('metaMaskSDK.disconnected')\n      }\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = normalizeChainId(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts()\n      if (accounts.length === 0) return\n\n      const chainId = normalizeChainId(connectInfo.chainId)\n      config.emitter.emit('connect', { accounts, chainId })\n\n      const provider = await this.getProvider()\n      if (provider) {\n        provider.removeListener('connect', this.onConnect.bind(this))\n        provider.on('accountsChanged', this.onAccountsChanged.bind(this) as any)\n        provider.on('chainChanged', this.onChainChanged as any)\n        provider.on('disconnect', this.onDisconnect.bind(this) as any)\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider()\n\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && (error as RpcError<1013>).code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return\n      }\n\n      // No need to remove 'metaMaskSDK.disconnected' from storage because `onDisconnect` is typically\n      // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n      // actually disconnected and we don't need to simulate it.\n      config.emitter.emit('disconnect')\n\n      provider.removeListener(\n        'accountsChanged',\n        this.onAccountsChanged.bind(this),\n      )\n      provider.removeListener('chainChanged', this.onChainChanged)\n      provider.removeListener('disconnect', this.onDisconnect.bind(this))\n      provider.on('connect', this.onConnect.bind(this) as any)\n    },\n  }))\n}\n", "import { type SafeAppProvider } from '@safe-global/safe-apps-provider'\nimport { type Opts } from '@safe-global/safe-apps-sdk'\nimport {\n  ProviderNotFoundError,\n  createConnector,\n  normalizeChainId,\n} from '@wagmi/core'\nimport type { Evaluate } from '@wagmi/core/internal'\nimport { getAddress } from 'viem'\n\nexport type SafeParameters = Evaluate<\n  Opts & {\n    /**\n     * Connector automatically connects when used as Safe App.\n     *\n     * This flag simulates the disconnect behavior by keeping track of connection status in storage\n     * and only autoconnecting when previously connected by user action (e.g. explicitly choosing to connect).\n     *\n     * @default false\n     */\n    shimDisconnect?: boolean | undefined\n  }\n>\n\nsafe.type = 'safe' as const\nexport function safe(parameters: SafeParameters = {}) {\n  const { shimDisconnect = false } = parameters\n\n  type Provider = SafeAppProvider | undefined\n  type Properties = {}\n  type StorageItem = { 'safe.disconnected': true }\n\n  let provider_: Provider | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'safe',\n    name: 'Safe',\n    type: safe.type,\n    async connect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const accounts = await this.getAccounts()\n      const chainId = await this.getChainId()\n\n      provider.on('disconnect', this.onDisconnect.bind(this))\n\n      // Remove disconnected shim if it exists\n      if (shimDisconnect) await config.storage?.removeItem('safe.disconnected')\n\n      return { accounts, chainId }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      provider.removeListener('disconnect', this.onDisconnect.bind(this))\n\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect)\n        await config.storage?.setItem('safe.disconnected', true)\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      return (await provider.request({ method: 'eth_accounts' })).map(\n        getAddress,\n      )\n    },\n    async getProvider() {\n      // Only allowed in iframe context\n      const isIframe =\n        typeof window !== 'undefined' && window?.parent !== window\n      if (!isIframe) return\n\n      if (!provider_) {\n        const { default: SafeAppsSDK } = await import(\n          '@safe-global/safe-apps-sdk'\n        )\n        let SDK: typeof SafeAppsSDK.default\n        if (\n          typeof SafeAppsSDK !== 'function' &&\n          typeof SafeAppsSDK.default === 'function'\n        )\n          SDK = SafeAppsSDK.default\n        else SDK = SafeAppsSDK as unknown as typeof SafeAppsSDK.default\n        const sdk = new SDK(parameters)\n\n        const safe = await sdk.safe.getInfo()\n        if (!safe) throw new Error('Could not load Safe information')\n        const { SafeAppProvider } = await import(\n          '@safe-global/safe-apps-provider'\n        )\n        provider_ = new SafeAppProvider(safe, sdk)\n      }\n      return provider_\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      return normalizeChainId(provider.chainId)\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          shimDisconnect &&\n          // If shim exists in storage, connector is disconnected\n          (await config.storage?.getItem('safe.disconnected'))\n        if (isDisconnected) return false\n\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    onAccountsChanged() {\n      // Not relevant for Safe because changing account requires app reload.\n    },\n    onChainChanged() {\n      // Not relevant for Safe because Safe smart contract wallets only exist on single chain.\n    },\n    onDisconnect() {\n      config.emitter.emit('disconnect')\n    },\n  }))\n}\n", "import {\n  ChainNotConfiguredError,\n  ProviderNotFoundError,\n  createConnector,\n  normalizeChainId,\n} from '@wagmi/core'\nimport {\n  type Evaluate,\n  type ExactPartial,\n  type Omit,\n} from '@wagmi/core/internal'\nimport { type EthereumProvider } from '@walletconnect/ethereum-provider'\nimport {\n  type Address,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getAddress,\n  numberToHex,\n} from 'viem'\n\ntype EthereumProviderOptions = Parameters<typeof EthereumProvider['init']>[0]\n\nexport type WalletConnectParameters = Evaluate<\n  {\n    /**\n     * If a new chain is added to a previously existing configured connector `chains`, this flag\n     * will determine if that chain should be considered as stale. A stale chain is a chain that\n     * WalletConnect has yet to establish a relationship with (e.g. the user has not approved or\n     * rejected the chain).\n     *\n     * Preface: Whereas WalletConnect v1 supported dynamic chain switching, WalletConnect v2 requires\n     * the user to pre-approve a set of chains up-front. This comes with consequent UX nuances (see below) when\n     * a user tries to switch to a chain that they have not approved.\n     *\n     * This flag mainly affects the behavior when a wallet does not support dynamic chain authorization\n     * with WalletConnect v2.\n     *\n     * If `true` (default), the new chain will be treated as a stale chain. If the user\n     * has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect\n     * session, the connector will disconnect upon the dapp auto-connecting, and the user will have to\n     * reconnect to the dapp (revalidate the chain) in order to approve the newly added chain.\n     * This is the default behavior to avoid an unexpected error upon switching chains which may\n     * be a confusing user experience (e.g. the user will not know they have to reconnect\n     * unless the dapp handles these types of errors).\n     *\n     * If `false`, the new chain will be treated as a validated chain. This means that if the user\n     * has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully\n     * auto-connect the user. This comes with the trade-off that the connector will throw an error\n     * when attempting to switch to the unapproved chain. This may be useful in cases where a dapp constantly\n     * modifies their configured chains, and they do not want to disconnect the user upon\n     * auto-connecting. If the user decides to switch to the unapproved chain, it is important that the\n     * dapp handles this error and prompts the user to reconnect to the dapp in order to approve\n     * the newly added chain.\n     *\n     * @default true\n     */\n    isNewChainsStale?: boolean\n  } & Omit<\n    EthereumProviderOptions,\n    | 'chains'\n    | 'events'\n    | 'optionalChains'\n    | 'optionalEvents'\n    | 'optionalMethods'\n    | 'methods'\n    | 'rpcMap'\n    | 'showQrModal'\n  > &\n    ExactPartial<Pick<EthereumProviderOptions, 'showQrModal'>>\n>\n\nwalletConnect.type = 'walletConnect' as const\nexport function walletConnect(parameters: WalletConnectParameters) {\n  const isNewChainsStale = parameters.isNewChainsStale ?? true\n\n  type Provider = Awaited<ReturnType<typeof EthereumProvider['init']>>\n  type NamespaceMethods =\n    | 'wallet_addEthereumChain'\n    | 'wallet_switchEthereumChain'\n  type Properties = {\n    connect(parameters?: { chainId?: number; pairingTopic?: string }): Promise<{\n      accounts: readonly Address[]\n      chainId: number\n    }>\n    getNamespaceChainsIds(): number[]\n    getNamespaceMethods(): NamespaceMethods[]\n    getRequestedChainsIds(): Promise<number[]>\n    isChainsStale(): Promise<boolean>\n    onConnect(connectInfo: ProviderConnectInfo): void\n    onDisplayUri(uri: string): void\n    onSessionDelete(data: { topic: string }): void\n    setRequestedChainsIds(chains: number[]): void\n    requestedChainsStorageKey: `${string}.requestedChains`\n  }\n  type StorageItem = {\n    [_ in Properties['requestedChainsStorageKey']]: number[]\n  }\n\n  let provider_: Provider | undefined\n  let providerPromise: Promise<typeof provider_>\n  const NAMESPACE = 'eip155'\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'walletConnect',\n    name: 'WalletConnect',\n    type: walletConnect.type,\n    async setup() {\n      const provider = await this.getProvider().catch(() => null)\n      if (!provider) return\n      provider.on('connect', this.onConnect.bind(this))\n      provider.on('session_delete', this.onSessionDelete.bind(this))\n    },\n    async connect({ chainId, ...rest } = {}) {\n      try {\n        const provider = await this.getProvider()\n        if (!provider) throw new ProviderNotFoundError()\n        provider.on('display_uri', this.onDisplayUri)\n\n        let targetChainId = chainId\n        if (!targetChainId) {\n          const state = (await config.storage?.getItem('state')) ?? {}\n          const isChainSupported = config.chains.some(\n            (x) => x.id === state.chainId,\n          )\n          if (isChainSupported) targetChainId = state.chainId\n          else targetChainId = config.chains[0]?.id\n        }\n        if (!targetChainId) throw new Error('No chains found on connector.')\n\n        const isChainsStale = await this.isChainsStale()\n        // If there is an active session with stale chains, disconnect current session.\n        if (provider.session && isChainsStale) await provider.disconnect()\n\n        // If there isn't an active session or chains are stale, connect.\n        if (!provider.session || isChainsStale) {\n          const optionalChains = config.chains\n            .filter((chain) => chain.id !== targetChainId)\n            .map((optionalChain) => optionalChain.id)\n          await provider.connect({\n            optionalChains: [targetChainId, ...optionalChains],\n            ...('pairingTopic' in rest\n              ? { pairingTopic: rest.pairingTopic }\n              : {}),\n          })\n\n          this.setRequestedChainsIds(config.chains.map((x) => x.id))\n        }\n\n        // If session exists and chains are authorized, enable provider for required chain\n        const accounts = (await provider.enable()).map((x) => getAddress(x))\n        const currentChainId = await this.getChainId()\n\n        provider.removeListener('display_uri', this.onDisplayUri)\n        provider.removeListener('connect', this.onConnect.bind(this))\n        provider.on('accountsChanged', this.onAccountsChanged.bind(this))\n        provider.on('chainChanged', this.onChainChanged)\n        provider.on('disconnect', this.onDisconnect.bind(this))\n        provider.on('session_delete', this.onSessionDelete.bind(this))\n\n        return { accounts, chainId: currentChainId }\n      } catch (error) {\n        if (\n          /(user rejected|connection request reset)/i.test(\n            (error as ProviderRpcError)?.message,\n          )\n        ) {\n          throw new UserRejectedRequestError(error as Error)\n        }\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      try {\n        await provider?.disconnect()\n      } catch (error) {\n        if (!/No matching key/i.test((error as Error).message)) throw error\n      } finally {\n        provider?.removeListener(\n          'accountsChanged',\n          this.onAccountsChanged.bind(this),\n        )\n        provider?.removeListener('chainChanged', this.onChainChanged)\n        provider?.removeListener('disconnect', this.onDisconnect.bind(this))\n        provider?.removeListener(\n          'session_delete',\n          this.onSessionDelete.bind(this),\n        )\n        provider?.on('connect', this.onConnect.bind(this))\n\n        this.setRequestedChainsIds([])\n      }\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return provider.accounts.map((x) => getAddress(x))\n    },\n    async getProvider({ chainId } = {}) {\n      async function initProvider() {\n        const optionalChains = config.chains.map((x) => x.id) as [number]\n        if (!optionalChains.length) return\n        const { EthereumProvider } = await import(\n          '@walletconnect/ethereum-provider'\n        )\n        return await EthereumProvider.init({\n          ...parameters,\n          disableProviderPing: true,\n          optionalChains,\n          projectId: parameters.projectId,\n          rpcMap: Object.fromEntries(\n            config.chains.map((chain) => [\n              chain.id,\n              chain.rpcUrls.default.http[0]!,\n            ]),\n          ),\n          showQrModal: parameters.showQrModal ?? true,\n        })\n      }\n\n      if (!provider_) {\n        if (!providerPromise) providerPromise = initProvider()\n        provider_ = await providerPromise\n        provider_?.events.setMaxListeners(Infinity)\n      }\n      if (chainId) await this.switchChain?.({ chainId })\n      return provider_!\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      return provider.chainId\n    },\n    async isAuthorized() {\n      try {\n        const [accounts, provider] = await Promise.all([\n          this.getAccounts(),\n          this.getProvider(),\n        ])\n\n        // If an account does not exist on the session, then the connector is unauthorized.\n        if (!accounts.length) return false\n\n        // If the chains are stale on the session, then the connector is unauthorized.\n        const isChainsStale = await this.isChainsStale()\n        if (isChainsStale && provider.session) {\n          await provider.disconnect().catch(() => {})\n          return false\n        }\n        return true\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      try {\n        const provider = await this.getProvider()\n        const namespaceChains = this.getNamespaceChainsIds()\n        const namespaceMethods = this.getNamespaceMethods()\n        const isChainApproved = namespaceChains.includes(chainId)\n\n        if (\n          !isChainApproved &&\n          namespaceMethods.includes('wallet_addEthereumChain')\n        ) {\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [\n              {\n                chainId: numberToHex(chain.id),\n                blockExplorerUrls: [chain.blockExplorers?.default.url],\n                chainName: chain.name,\n                nativeCurrency: chain.nativeCurrency,\n                rpcUrls: [...chain.rpcUrls.default.http],\n              },\n            ],\n          })\n          const requestedChains = await this.getRequestedChainsIds()\n          this.setRequestedChainsIds([...requestedChains, chainId])\n        }\n\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chainId) }],\n        })\n        return chain\n      } catch (error) {\n        const message =\n          typeof error === 'string'\n            ? error\n            : (error as ProviderRpcError)?.message\n        if (/user rejected request/i.test(message))\n          throw new UserRejectedRequestError(error as Error)\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = normalizeChainId(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const chainId = normalizeChainId(connectInfo.chainId)\n      const accounts = await this.getAccounts()\n      config.emitter.emit('connect', { accounts, chainId })\n    },\n    async onDisconnect(_error) {\n      this.setRequestedChainsIds([])\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      provider.removeListener(\n        'accountsChanged',\n        this.onAccountsChanged.bind(this),\n      )\n      provider.removeListener('chainChanged', this.onChainChanged)\n      provider.removeListener('disconnect', this.onDisconnect.bind(this))\n      provider.removeListener('session_delete', this.onSessionDelete.bind(this))\n      provider.on('connect', this.onConnect.bind(this))\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', { type: 'display_uri', data: uri })\n    },\n    onSessionDelete() {\n      this.onDisconnect()\n    },\n    getNamespaceChainsIds() {\n      if (!provider_) return []\n      const chainIds = provider_.session?.namespaces[NAMESPACE]?.chains?.map(\n        (chain) => parseInt(chain.split(':')[1] || ''),\n      )\n      return chainIds ?? []\n    },\n    getNamespaceMethods() {\n      if (!provider_) return []\n      const methods = provider_.session?.namespaces[NAMESPACE]\n        ?.methods as NamespaceMethods[]\n      return methods ?? []\n    },\n    async getRequestedChainsIds() {\n      return (\n        (await config.storage?.getItem(this.requestedChainsStorageKey)) ?? []\n      )\n    },\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     *\n     * There are exceptions however:\n     * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,\n     *    then the chain is not considered stale.\n     * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is\n     *    not considered stale.\n     *\n     * For the above cases, chain validation occurs dynamically when the user\n     * attempts to switch chain.\n     *\n     * Also check that dapp supports at least 1 chain from previously approved session.\n     */\n    async isChainsStale() {\n      const namespaceMethods = this.getNamespaceMethods()\n      if (namespaceMethods.includes('wallet_addEthereumChain')) return false\n      if (!isNewChainsStale) return false\n\n      const connectorChains = config.chains.map((x) => x.id)\n      const namespaceChains = this.getNamespaceChainsIds()\n      if (\n        namespaceChains.length &&\n        !namespaceChains.some((id) => connectorChains.includes(id))\n      )\n        return false\n\n      const requestedChains = await this.getRequestedChainsIds()\n      return !connectorChains.every((id) => requestedChains.includes(id))\n    },\n    async setRequestedChainsIds(chains) {\n      await config.storage?.setItem(this.requestedChainsStorageKey, chains)\n    },\n    get requestedChainsStorageKey() {\n      return `${this.id}.requestedChains` as Properties['requestedChainsStorageKey']\n    },\n  }))\n}\n", null, null],
  "mappings": "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",
  "names": ["_a", "chain", "error", "_a", "error", "_a", "safe", "_a", "chain"]
}
