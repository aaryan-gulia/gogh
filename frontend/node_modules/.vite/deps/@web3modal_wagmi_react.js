import {
  mainnet
} from "./chunk-5EHGGWYL.js";
import {
  W3mFrameHelpers,
  W3mFrameRpcConstants,
  Web3ModalScaffold,
  getCaipDefaultChain,
  getEmailCaipNetworks,
  getWalletConnectCaipNetworks
} from "./chunk-XL4SI5RT.js";
import "./chunk-RYIILSRX.js";
import {
  ConstantsUtil as ConstantsUtil2,
  HelpersUtil,
  PresetsUtil
} from "./chunk-QX26WUIB.js";
import "./chunk-AMZF4XDB.js";
import {
  ConstantsUtil
} from "./chunk-IRDXVXNP.js";
import "./chunk-OFSQQSLQ.js";
import "./chunk-6Y7ERPPG.js";
import "./chunk-U6O6RVJR.js";
import "./chunk-FKGVX4HN.js";
import {
  connect,
  disconnect,
  getAccount,
  getBalance,
  getEnsAvatar,
  getEnsName,
  signMessage,
  switchChain,
  watchAccount,
  watchConnectors
} from "./chunk-55SNBBPH.js";
import "./chunk-DB65SB25.js";
import "./chunk-VH7KT673.js";
import "./chunk-3HGR6ZGG.js";
import "./chunk-TBJUMJ3E.js";
import "./chunk-QQWH4Y5Y.js";
import "./chunk-6I4IKEVR.js";
import {
  require_react
} from "./chunk-MBWFDVNC.js";
import {
  __toESM
} from "./chunk-JUYIN33I.js";

// node_modules/@web3modal/scaffold-react/dist/esm/index.js
var import_react = __toESM(require_react());
var modal = void 0;
function getWeb3Modal(web3modal) {
  if (web3modal) {
    modal = web3modal;
  }
}
function useWeb3ModalTheme() {
  if (!modal) {
    throw new Error('Please call "createWeb3Modal" before using "useWeb3ModalTheme" hook');
  }
  function setThemeMode(themeMode2) {
    modal == null ? void 0 : modal.setThemeMode(themeMode2);
  }
  function setThemeVariables(themeVariables2) {
    modal == null ? void 0 : modal.setThemeVariables(themeVariables2);
  }
  const [themeMode, setInternalThemeMode] = (0, import_react.useState)(modal.getThemeMode());
  const [themeVariables, setInternalThemeVariables] = (0, import_react.useState)(modal.getThemeVariables());
  (0, import_react.useEffect)(() => {
    const unsubscribe = modal == null ? void 0 : modal.subscribeTheme((state) => {
      setInternalThemeMode(state.themeMode);
      setInternalThemeVariables(state.themeVariables);
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, []);
  return {
    themeMode,
    themeVariables,
    setThemeMode,
    setThemeVariables
  };
}
function useWeb3Modal() {
  if (!modal) {
    throw new Error('Please call "createWeb3Modal" before using "useWeb3Modal" hook');
  }
  async function open(options) {
    await (modal == null ? void 0 : modal.open(options));
  }
  async function close() {
    await (modal == null ? void 0 : modal.close());
  }
  return { open, close };
}
function useWeb3ModalState() {
  if (!modal) {
    throw new Error('Please call "createWeb3Modal" before using "useWeb3ModalState" hook');
  }
  const [state, setState] = (0, import_react.useState)(modal.getState());
  (0, import_react.useEffect)(() => {
    const unsubscribe = modal == null ? void 0 : modal.subscribeState((newState) => {
      setState({ ...newState });
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, []);
  return state;
}
function useWeb3ModalEvents() {
  if (!modal) {
    throw new Error('Please call "createWeb3Modal" before using "useWeb3ModalState" hook');
  }
  const [event, setEvents] = (0, import_react.useState)(modal.getEvent());
  (0, import_react.useEffect)(() => {
    const unsubscribe = modal == null ? void 0 : modal.subscribeEvents((newEvent) => {
      setEvents({ ...newEvent });
    });
    return () => {
      unsubscribe == null ? void 0 : unsubscribe();
    };
  }, []);
  return event;
}

// node_modules/@web3modal/wagmi/dist/esm/src/client.js
var Web3Modal = class extends Web3ModalScaffold {
  constructor(options) {
    const { wagmiConfig, siweConfig, defaultChain, tokens, _sdkVersion, ...w3mOptions } = options;
    if (!wagmiConfig) {
      throw new Error("web3modal:constructor - wagmiConfig is undefined");
    }
    if (!w3mOptions.projectId) {
      throw new Error("web3modal:constructor - projectId is undefined");
    }
    const networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => {
        const chainId = HelpersUtil.caipNetworkIdToNumber(caipNetwork == null ? void 0 : caipNetwork.id);
        if (chainId) {
          await switchChain(this.wagmiConfig, { chainId });
        }
      },
      getApprovedCaipNetworksData: async () => new Promise((resolve) => {
        var _a, _b;
        const connections = new Map(wagmiConfig.state.connections);
        const connection = connections.get(wagmiConfig.state.current || "");
        if (((_a = connection == null ? void 0 : connection.connector) == null ? void 0 : _a.id) === ConstantsUtil2.EMAIL_CONNECTOR_ID) {
          resolve(getEmailCaipNetworks());
        } else if (((_b = connection == null ? void 0 : connection.connector) == null ? void 0 : _b.id) === ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID) {
          const connector = wagmiConfig.connectors.find((c) => c.id === ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID);
          resolve(getWalletConnectCaipNetworks(connector));
        }
        resolve({ approvedCaipNetworkIds: void 0, supportsAllNetworks: true });
      })
    };
    const connectionControllerClient = {
      connectWalletConnect: async (onUri) => {
        var _a;
        const connector = wagmiConfig.connectors.find((c) => c.id === ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID);
        if (!connector) {
          throw new Error("connectionControllerClient:getWalletConnectUri - connector is undefined");
        }
        const provider = await connector.getProvider();
        provider.on("display_uri", (data) => {
          onUri(data);
        });
        const chainId = HelpersUtil.caipNetworkIdToNumber((_a = this.getCaipNetwork()) == null ? void 0 : _a.id);
        await connect(this.wagmiConfig, { connector, chainId });
      },
      connectExternal: async ({ id, provider, info }) => {
        var _a, _b;
        const connector = wagmiConfig.connectors.find((c) => c.id === id);
        if (!connector) {
          throw new Error("connectionControllerClient:connectExternal - connector is undefined");
        }
        if (provider && info && connector.id === ConstantsUtil2.EIP6963_CONNECTOR_ID) {
          (_a = connector.setEip6963Wallet) == null ? void 0 : _a.call(connector, { provider, info });
        }
        const chainId = HelpersUtil.caipNetworkIdToNumber((_b = this.getCaipNetwork()) == null ? void 0 : _b.id);
        await connect(this.wagmiConfig, { connector, chainId });
      },
      checkInstalled: (ids) => {
        const injectedConnector = this.getConnectors().find((c) => c.type === "INJECTED");
        if (!ids) {
          return Boolean(window.ethereum);
        }
        if (injectedConnector) {
          if (!(window == null ? void 0 : window.ethereum)) {
            return false;
          }
          return ids.some((id) => {
            var _a;
            return Boolean((_a = window.ethereum) == null ? void 0 : _a[String(id)]);
          });
        }
        return false;
      },
      disconnect: async () => {
        var _a;
        await disconnect(this.wagmiConfig);
        if ((_a = siweConfig == null ? void 0 : siweConfig.options) == null ? void 0 : _a.signOutOnDisconnect) {
          await siweConfig.signOut();
        }
      },
      signMessage: async (message) => signMessage(this.wagmiConfig, { message })
    };
    super({
      networkControllerClient,
      connectionControllerClient,
      siweControllerClient: siweConfig,
      defaultChain: getCaipDefaultChain(defaultChain),
      tokens: HelpersUtil.getCaipTokens(tokens),
      _sdkVersion: _sdkVersion ?? `html-wagmi-${ConstantsUtil2.VERSION}`,
      ...w3mOptions
    });
    this.hasSyncedConnectedAccount = false;
    this.options = void 0;
    this.options = options;
    this.wagmiConfig = wagmiConfig;
    this.syncRequestedNetworks([...wagmiConfig.chains]);
    this.syncConnectors([...wagmiConfig.connectors]);
    watchConnectors(this.wagmiConfig, {
      onChange: (connectors) => this.syncConnectors(connectors)
    });
    watchAccount(this.wagmiConfig, {
      onChange: (accountData) => this.syncAccount({ ...accountData })
    });
  }
  getState() {
    const state = super.getState();
    return {
      ...state,
      selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state.selectedNetworkId)
    };
  }
  subscribeState(callback) {
    return super.subscribeState((state) => callback({
      ...state,
      selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state.selectedNetworkId)
    }));
  }
  syncRequestedNetworks(chains) {
    const requestedCaipNetworks = chains == null ? void 0 : chains.map((chain) => {
      var _a, _b;
      return {
        id: `${ConstantsUtil2.EIP155}:${chain.id}`,
        name: chain.name,
        imageId: PresetsUtil.EIP155NetworkImageIds[chain.id],
        imageUrl: (_b = (_a = this.options) == null ? void 0 : _a.chainImages) == null ? void 0 : _b[chain.id]
      };
    });
    this.setRequestedCaipNetworks(requestedCaipNetworks ?? []);
  }
  async syncAccount({ address, isConnected, chainId }) {
    this.resetAccount();
    this.syncNetwork();
    if (isConnected && address && chainId) {
      const caipAddress = `${ConstantsUtil2.EIP155}:${chainId}:${address}`;
      this.setIsConnected(isConnected);
      this.setCaipAddress(caipAddress);
      await Promise.all([
        this.syncProfile(address, chainId),
        this.syncBalance(address, chainId),
        this.fetchTokenBalance(),
        this.getApprovedCaipNetworksData()
      ]);
      this.hasSyncedConnectedAccount = true;
    } else if (!isConnected && this.hasSyncedConnectedAccount) {
      this.resetWcConnection();
      this.resetNetwork();
    }
  }
  async syncNetwork() {
    var _a, _b, _c, _d;
    const { address, isConnected, chainId } = getAccount(this.wagmiConfig);
    const chain = this.wagmiConfig.chains.find((c) => c.id === chainId);
    if (chain || chainId) {
      const name = (chain == null ? void 0 : chain.name) ?? (chainId == null ? void 0 : chainId.toString());
      const id = Number((chain == null ? void 0 : chain.id) ?? chainId);
      const caipChainId = `${ConstantsUtil2.EIP155}:${id}`;
      this.setCaipNetwork({
        id: caipChainId,
        name,
        imageId: PresetsUtil.EIP155NetworkImageIds[id],
        imageUrl: (_b = (_a = this.options) == null ? void 0 : _a.chainImages) == null ? void 0 : _b[id]
      });
      if (isConnected && address && chainId) {
        const caipAddress = `${ConstantsUtil2.EIP155}:${id}:${address}`;
        this.setCaipAddress(caipAddress);
        if ((_d = (_c = chain == null ? void 0 : chain.blockExplorers) == null ? void 0 : _c.default) == null ? void 0 : _d.url) {
          const url = `${chain.blockExplorers.default.url}/address/${address}`;
          this.setAddressExplorerUrl(url);
        } else {
          this.setAddressExplorerUrl(void 0);
        }
        if (this.hasSyncedConnectedAccount) {
          await this.syncProfile(address, chainId);
          await this.syncBalance(address, chainId);
        }
      }
    }
  }
  async syncProfile(address, chainId) {
    if (chainId !== mainnet.id) {
      this.setProfileName(null);
      this.setProfileImage(null);
      return;
    }
    try {
      const { name, avatar } = await this.fetchIdentity({
        caipChainId: `${ConstantsUtil2.EIP155}:${chainId}`,
        address
      });
      this.setProfileName(name);
      this.setProfileImage(avatar);
    } catch {
      const profileName = await getEnsName(this.wagmiConfig, { address, chainId });
      if (profileName) {
        this.setProfileName(profileName);
        const profileImage = await getEnsAvatar(this.wagmiConfig, {
          name: profileName,
          chainId
        });
        if (profileImage) {
          this.setProfileImage(profileImage);
        }
      }
    }
  }
  async syncBalance(address, chainId) {
    var _a, _b, _c;
    const chain = this.wagmiConfig.chains.find((c) => c.id === chainId);
    if (chain) {
      const balance = await getBalance(this.wagmiConfig, {
        address,
        chainId: chain.id,
        token: (_c = (_b = (_a = this.options) == null ? void 0 : _a.tokens) == null ? void 0 : _b[chain.id]) == null ? void 0 : _c.address
      });
      this.setBalance(balance.formatted, balance.symbol);
      return;
    }
    this.setBalance(void 0, void 0);
  }
  syncConnectors(connectors) {
    const uniqueIds = /* @__PURE__ */ new Set();
    const filteredConnectors = connectors.filter((item) => !uniqueIds.has(item.id) && uniqueIds.add(item.id));
    const w3mConnectors = [];
    const coinbaseSDKId = ConstantsUtil2.COINBASE_SDK_CONNECTOR_ID;
    const coinbaseConnector = filteredConnectors.find((c) => c.id === ConstantsUtil.CONNECTOR_RDNS_MAP[coinbaseSDKId]);
    filteredConnectors.forEach(({ id, name, type, icon }) => {
      var _a, _b;
      const shouldSkip = coinbaseConnector && id === coinbaseSDKId || ConstantsUtil2.EMAIL_CONNECTOR_ID === id;
      if (!shouldSkip) {
        w3mConnectors.push({
          id,
          explorerId: PresetsUtil.ConnectorExplorerIds[id],
          imageUrl: ((_b = (_a = this.options) == null ? void 0 : _a.connectorImages) == null ? void 0 : _b[id]) ?? icon,
          name: PresetsUtil.ConnectorNamesMap[id] ?? name,
          imageId: PresetsUtil.ConnectorImageIds[id],
          type: PresetsUtil.ConnectorTypesMap[type] ?? "EXTERNAL"
        });
      }
    });
    this.setConnectors(w3mConnectors);
    this.syncEmailConnector(filteredConnectors);
  }
  async syncEmailConnector(connectors) {
    const emailConnector = connectors.find(({ id }) => id === ConstantsUtil2.EMAIL_CONNECTOR_ID);
    if (emailConnector) {
      const provider = await emailConnector.getProvider();
      this.addConnector({
        id: ConstantsUtil2.EMAIL_CONNECTOR_ID,
        type: "EMAIL",
        name: "Email",
        provider
      });
      this.listenEmailConnector(emailConnector);
      this.listenModal(emailConnector);
    }
  }
  async listenEmailConnector(connector) {
    if (typeof window !== "undefined" && connector) {
      super.setLoading(true);
      const provider = await connector.getProvider();
      const isLoginEmailUsed = provider.getLoginEmailUsed();
      super.setLoading(isLoginEmailUsed);
      if (isLoginEmailUsed) {
        this.setIsConnected(false);
      }
      provider.onInitSmartAccount((isDeployed) => {
        this.setSmartAccountDeployed(isDeployed);
      });
      provider.onRpcRequest((request) => {
        if (W3mFrameHelpers.checkIfRequestExists(request)) {
          if (!W3mFrameHelpers.checkIfRequestIsAllowed(request)) {
            super.open({ view: "ApproveTransaction" });
          }
        } else {
          super.open();
          const method = W3mFrameHelpers.getRequestMethod(request);
          console.error(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_MESSAGE, { method });
          setTimeout(() => {
            this.showErrorMessage(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
          }, 300);
          provider.rejectRpcRequest();
        }
      });
      provider.onRpcResponse(() => {
        super.close();
      });
      provider.onNotConnected(() => {
        this.setIsConnected(false);
        super.setLoading(false);
      });
      provider.onIsConnected(() => {
        this.setIsConnected(true);
        super.setLoading(false);
      });
    }
  }
  async listenModal(connector) {
    const provider = await connector.getProvider();
    this.subscribeState((val) => {
      if (!val.open) {
        provider.rejectRpcRequest();
      }
    });
  }
};

// node_modules/@web3modal/wagmi/dist/esm/exports/react/index.js
var modal2 = void 0;
function createWeb3Modal(options) {
  if (!modal2) {
    modal2 = new Web3Modal({ ...options, _sdkVersion: `react-wagmi-${ConstantsUtil2.VERSION}` });
    getWeb3Modal(modal2);
  }
  return modal2;
}
export {
  createWeb3Modal,
  useWeb3Modal,
  useWeb3ModalEvents,
  useWeb3ModalState,
  useWeb3ModalTheme
};
//# sourceMappingURL=@web3modal_wagmi_react.js.map
